{"version":3,"sources":["RateLimitedQueue.js"],"names":["findIndex","array","predicate","i","length","createCancelError","Error","module","exports","limit","start","Infinity","startNow","activeRequests","queuedHandlers","_call","fn","done","cancelActive","err","abort","_queueNext","Promise","resolve","then","_next","next","shift","handler","_queue","options","priority","_dequeue","index","other","push","splice","indexOf","run","queueOptions","wrapPromiseFunction","args","queuedRequest","outerPromise","reject","cancelError","innerPromise","result"],"mappings":"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","sourcesContent":["/**\n * Array.prototype.findIndex ponyfill for old browsers.\n */\nfunction findIndex (array, predicate) {\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i])) return i\n  }\n  return -1\n}\n\nfunction createCancelError () {\n  return new Error('Cancelled')\n}\n\nmodule.exports = class RateLimitedQueue {\n  constructor (limit, start = true) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity\n    } else {\n      this.limit = limit\n    }\n\n    this.startNow = start;\n\n    this.activeRequests = 0\n    this.queuedHandlers = []\n  }\n\n  _call (fn) {\n    this.activeRequests += 1\n\n    let done = false\n\n    let cancelActive\n    try {\n      cancelActive = fn()\n    } catch (err) {\n      this.activeRequests -= 1\n      throw err\n    }\n\n    return {\n      abort: () => {\n        if (done) return\n        done = true\n        this.activeRequests -= 1\n        cancelActive()\n        this._queueNext()\n      },\n\n      done: () => {\n        if (done) return\n        done = true\n        this.activeRequests -= 1\n        this._queueNext()\n      }\n    }\n  }\n\n  _queueNext () {\n    // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n    Promise.resolve().then(() => {\n      this._next()\n    })\n  }\n\n  _next () {\n    if (!this.startNow) {\n      return;\n    }\n    if (this.activeRequests >= this.limit) {\n      return\n    }\n    if (this.queuedHandlers.length === 0) {\n      return\n    }\n\n    // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n    const next = this.queuedHandlers.shift()\n    const handler = this._call(next.fn)\n    next.abort = handler.abort\n    next.done = handler.done\n  }\n\n  _queue (fn, options = {}) {\n    const handler = {\n      fn,\n      priority: options.priority || 0,\n      abort: () => {\n        this._dequeue(handler)\n      },\n      done: () => {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug')\n      }\n    }\n\n    const index = findIndex(this.queuedHandlers, (other) => {\n      return handler.priority > other.priority\n    })\n    if (index === -1) {\n      this.queuedHandlers.push(handler)\n    } else {\n      this.queuedHandlers.splice(index, 0, handler)\n    }\n    return handler\n  }\n\n  _dequeue (handler) {\n    const index = this.queuedHandlers.indexOf(handler)\n    if (index !== -1) {\n      this.queuedHandlers.splice(index, 1)\n    }\n  }\n\n  run (fn, queueOptions) {\n    if (this.startNow && this.activeRequests < this.limit) {\n      return this._call(fn)\n    }\n    return this._queue(fn, queueOptions)\n  }\n\n  start () {\n    this.startNow = true;\n    for (let i = 0; i < this.limit; i++) {\n      this._next();\n    }\n  }\n\n  wrapPromiseFunction (fn, queueOptions) {\n    return (...args) => {\n      let queuedRequest\n      const outerPromise = new Promise((resolve, reject) => {\n        queuedRequest = this.run(() => {\n          let cancelError\n          let innerPromise\n          try {\n            innerPromise = Promise.resolve(fn(...args))\n          } catch (err) {\n            innerPromise = Promise.reject(err)\n          }\n\n          innerPromise.then((result) => {\n            if (cancelError) {\n              reject(cancelError)\n            } else {\n              queuedRequest.done()\n              resolve(result)\n            }\n          }, (err) => {\n            if (cancelError) {\n              reject(cancelError)\n            } else {\n              queuedRequest.done()\n              reject(err)\n            }\n          })\n\n          return () => {\n            cancelError = createCancelError()\n          }\n        }, queueOptions)\n      })\n\n      outerPromise.abort = () => {\n        queuedRequest.abort()\n      }\n\n      return outerPromise\n    }\n  }\n}\n"]}